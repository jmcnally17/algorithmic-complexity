# Algorithmic Complexity

This project contains a timing framework for measuring the efficiency of algorithms. This timing framework has been applied on in built JS functions and on custom built JS functions I've made myself to test my skills of algorithm desgin.

#### Custom Functions

- last(array): returns the last element from the array passed in
- reverse(array): reverses the order of the array passed in and returns the updated array
- shuffle(array): returns a new array which contains all the elements of the original in a random order
- duplicate(array): returns an array containing the elements that appeared more than once in the original array passed in
- fibonacci(n): returns an array containing the first n-terms in the fibonacci sequence
- subSequenceSum(array, target): returns true if a sub-sequence in the array passed in sums up to the target

## Graphs

### In Built JS Functions

#### reverse()

![Timing data for in built reverse()](graphs/in-built-reverse.png)

#### sort()

![Timing data for in built sort()](graphs/in-built-sort.png)

### Custom JS Functions

#### last()

![Timing data for custom last()](graphs/custom-last.png)

#### reverse()

![Timing data for custom reverse()](graphs/custom-reverse.png)

#### shuffle()

![Timing data for custom shuffle()](graphs/custom-shuffle.png)

#### duplicate()

![Timing data for custom duplicate()](graphs/custom-duplicate.png)

#### fibonacci()

![Timing data for custom fibonacci()](graphs/custom-fibonacci.png)

#### subSequenceSum()

![Timing data for custom subSequenceSum()](graphs/custom-sub-sequence-sum.png)
